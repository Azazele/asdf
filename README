asdf: another system definition facility                 -*- Text -*-

$Id: README,v 1.16 2002/02/28 03:51:26 dan_b Exp $

This system definition utility talks in terms of 'components' and
'operations'.

Components form systems: a component represents a source file, or a
collection of components.  A system is therefore a component,
recursively formed of a tree of subcomponents.

Operations are instantiated then performed on the nodes of a tree to
do things like

 - compile all its files
 - load the files into a running lisp environment
 - copy its source files somewhere else

Operations can be invoked directly, or examined to see what their
effects would be without performing them.  There are a bunch of 
methods specialised on operation and component type which actually do
the grunt work.

asdf is extensible to new operations and to new component types.  This
allows the addition of behaviours: for example, a new component could
be added for Java JAR archives, and methods specialised on
compile-op added for it that would accomplish the relevant
actions.

* Inspiration

** mk-defsystem (defsystem-3.x)

We aim to solve basically the same problems as mk-defsystem does.
However, our architecture for extensibility better exploits CL
language features (and is documented), and we intend to be portable
rather than just widely-ported.  No slight on the mk-defsystem authors
and maintainers is intended here; that implementation has the
unenviable task of supporting non-ANSI implementations, which I
propose to ignore.

The surface defsystem syntax of asdf is more-or-less compatible with
mk-defsystem

The mk-defsystem code for topologically sorting a module's dependency
list was very useful.

** defsystem-4 proposal

Marco and Peter's proposal for defsystem 4 served as the driver for
many of the features in here.  Notable differences are

- we don't specify output files or output file extensions as part of
  the system

  If you want to find out what files an operation would create, ask
  the operation

- we don't deal with CL packages

  If you want to compile in a particular package, use an in-package
  form in that file (ilisp will like you more if you do this anyway)

- there is no proposal here that defsystem does version control.  

  A system has a given version which can be used to check
  dependencies, but that's all.

The defsystem 4 proposal tends to look more at the external features,
whereas this one centres on a protocol for system introspection.

** kmp's "The Description of Large Systems", MIT AI Memu 801

Available in updated-for-CL form on the web at 
http://world.std.com/~pitman/Papers/Large-Systems.html

In our implementation we borrow kmp's overall PROCESS-OPTIONS and
concept to deal with creating component trees from defsystem surface
syntax.

* component

** a component has:

*** A name (required)

This is a string.  It must be a suitable value for the :name initarg
to make-pathname in whatever filesystem the system is to be found.

*** a version identifier (optional, will default to parent's version)

This is used by the test-system-version operation (see later).

*** dependencies on its siblings  (optional but often necessary)

There is an excitingly complicated relationship between the initarg
and the method that you use to ask about dependencies

Dependencies are between (operation component) pairs.  In your
initargs, you can say

:in-order-to ((compile-op (load-op (and "a" "b")) (compile-op "c"))
	      (load-op (load-op "foo")))

- before performing compile-op on this component, we must perform
load-op on both of "a" and "b" and compile-op on c, 
- before performing load-op, we have to load "foo"

The syntax is approximately

(this-op {(other-op required-components)}+)

required-components := component-name
		     | (or required-components required-components)
                     | (and required-components required-components)
                     | (required-components required-components)

component-name := string
                | (version string object)

The last case in required-components is a shorthand for the 'and'
form, as and is usually the common case

The dependency mechanism can also be used to introduce conditional
compilation based on features of the Lisp environment.  A 
dependency on (feature foo) is satisfied if foo is in the
*features* list -

(:module "deps"
	 :if-component-dep-fails :try-next
         (:file "sbcl-dep"
		:in-order-to ((compile-op (feature :sbcl))))
	 (:file "cmucl-dep"
	        :in-order-to ((compile-op (feature :cmu)))))
 
[ This is on a par with what ACL defsystem does, though the and/or
stuff is of our own invention.  mk-defsystem is less general: it has
an implied dependency

  for all x, (load x) depends on (compile x)

and using a :depends-on argument to say that b depends on a _actually_
means that

  (compile b) depends on (load a) 

This is insufficient for e.g. the McCLIM system, which requires that
all the files are loaded before any of them can be compiled ]

In asdf, the dependency information for a given component and
operation can be queried using (component-depends-on operation
component), which returns a list

((load-op "a") (load-op "b") (compile-op "c") ...)

component-depends-on can be subclassed for more specific
component/operation types: these need to (call-next-method) and append
the answer to their dependency, unless they have a good reason for
completely overriding the default dependencies

(If it weren't for CLISP, we'd be using a LIST method combination to
do this transparently.  But, we need to support CLISP.  If you have
the time for some CLISP hacking, I'm sure they'd welcome your fixes)

*** a pathname

Optional, may be inferred from name, type (the subclass of
source-file), and location of parent.

The rules for this inference are:

(for source-files)
- the host is taken from the parent
- pathname type is (rassoc classname  *known-extensions* :test 'equal)
- the pathname case option is :local
- the pathname is merged against the parent

(for modules)
- the host is taken from the parent
- the name and type are NIL
- the directory is (:relative component-name)
- the pathname case option is :local
- the pathname is merged against the parent

Note that a component doesn't actually have any references to its
parent, so this inference will only be valid in the context of a
system operation (a special variable is bound to the location of
the parent while a child is processed)

Note that the DEFSYSTEM operator (used to create a "top-level" system)
does additional processing to set the filesystem location of the
top component in that system.  This is detailed elsewhere

** components are subclassed into 

*** 'source-file'

A source file is any file that the system does not know how to
generate from other components of the system. 

(Note that this is not necessarily the same thing as "a file
containing data that is typically fed to a compiler".  If a file is
generated by some pre-processor stage (e.g. a ".h" file from ".h.in"
by autoconf) then it is not, by this definition, a source file.
Conversely, we might have a graphic file that cannot be automatically
regenerated, or a proprietary shared library that we received as a
binary: these do count as source files for our purposes.  All
suggestions for better terminology gratefully received)

Subclasses of source-file exist for various languages.  

*** 'module', a collection of sub-components

This has extra slots for

 :components - the components contained in this module

 :default-component-class - for child components which don't specify
   their class explicitly

 :if-component-dep-fails takes one of the values :fail, :try-next, :ignore 
   (default value is :fail).  The other values can be used for implementing
   conditional compilation based on implementation *features*, where
   it is not necessary for all files in a module to be compiled

The default operation knows how to traverse a module, so most
operations will not need to provide methods specialised on modules.

A system object is usually a module. 

The module may be subclassed to represent components such as
foreign-language linked libraries or archive files.

* operation

An operation is instantiated whenever the user asks that an operation
be performed, inspected, or etc.  The operation object contains
whatever state is relevant to this purpose (perhaps a list of visited
nodes, for example) but primarily is a nice thing to specialise
operation methods on and easier than having them all be EQL methods.

There are no differences between standard operations and user-defined
operations, except that the user is respectfully requested to keep his
(or more importantly, our) package namespace clean

** invoking operations

(oos operation system &rest keywords-args)

keyword-args are passed to the make-instance call when creating the
operation: valid keywords depend on the initargs that the operation is
defined to accept.  Note that dependencies may cause the operation to
invoke other operations on the system or its components: the new
operation will be created with the same initargs as the original one

** standard operations

*** compile-op &key proclamations

When creating a new component, you should provide methods for this.  
You probably don't want to use it as a user, though.  See below.

*** load-op &key proclamations

This is roughly equivalent to the mk-defsystem 'compile' operation.
Compiling a system usually involves loading each component after it is
compiled - we've changed the name of this operation to make it more
explicit what is happening

If proclamations are supplied, they will be proclaimed.  This is a
good place to specify optimization settings

The default methods for load-op compile files before loading them.
For parity, your own methods on new component types should probably do
so too

*** load-source-op

Sometimes systems have knotty dependencies which require that sources
are loaded before they can be compiled.  This is how you do that.

If you are creating a component type, you need to implement this
operation - at least, where meaningful.

*** test-system-version &key minimum

Asks the system whether it satisfies a version requirement.

The default method accepts a string, which is expected to contain of a
number of integers separated by #\. characters.  The method is not
recursive.  The component satisfies the version dependency if it has
the same major number as required and each of its sub-versions is
greater than or equal to the sub-version number required.

(defun version-satisfies (x y)
  (labels ((bigger (x y)
	     (cond ((not y) t)
		   ((not x) nil)
		   ((> (car x) (car y)) t)
		   ((= (car x) (car y))
		    (bigger (cdr x) (cdr y))))))
    (and (= (car x) (car y))
	 (or (not (cdr y)) (bigger (cdr x) (cdr y))))))

If that doesn't work for your system, you can override it.  I hope
yoyu have as much fun writing the new method as #lisp did
reimplementing this one. 

** Creating new operations

subclass operation, provide methods for source-file for 

- output-files
- perform
   The perform method must call output-files to find out where to
   put its files, because the user is allowed to override output-files
   for local policy
- explain
- operation-done-p, if you don't like the default one

* System definitions

** System designators

Strings and symbols are treated as system designators.  They are
transformed into actual system objects using

(find-system system-designator) => a MODULE object

In the case of a symbol, 
- the symbol name is taken
- if the system name is monocase and not in customary case for the
   filesystem, its case is inverted

No case translation is done for systems named by strings

This attempts to find the system in a file on the disk.  This file has
the name of the system, the type "asd", and is looked for in each
of the directories given by evaluating members of *central-registry*.
The first matching file is considered, whether or not it turns out to
actually define the appropriate system

If a suitable file exists, it is loaded if

- there is no system of that name in memory, 
- the file's last-modified time exceeds the last-modified time of the
  system in memory

When system definitions are loaded from .asd files, a new scratch
package is created for them to load into, so that different systems do
not overwrite each others operations.  The user may also wish to (and
is recommended to) include defpackage and in-package forms in his
system definition files, however, so that they can be loaded manually
if need be.

** Syntax

Systems can always be constructed programmatically by instantiating
components using make-instance.  For most purposes, however, it is
likely that people will want a static defystem form. 

asdf is based around the principle that components should not have to
know defsystem syntax.  That is, the initargs that a component accepts
are not necessarily related to the defsystem form which creates it.

A defsystem parser must implement a `defsystem' macro, which can
be named for compatibility with whatever other system definition
utility is being emulated.  It should instantiate components in
accordance with whatever language it accepts, and register the topmost
component using REGISTER-SYSTEM

** Native syntax

The native syntax is inspired by mk-defsystem, to the extent that it
should be possible to take most straightforward mk- system definitions
and run them unchanged or with only light editing.  For my
convenience, this turns out to be basically the same as the initargs
to the various components, with a few extensions for convenience
               
system-definition := ( defsystem system-designator {option}* )

option := :components component-list
        | :pathname pathname
        | :default-component-class
        | :perform method-form 
        | :explain method-form
	| :output-files  method-form
        | :operation-done-p method-form
        | :depends-on ( {simple-component-name}* ) 
	| :serialize [ t | nil ]
        | :in-order-to ( {dependency}+ )

component-list := ( {component-def}* )
                
component-def  := simple-component-name
                | ( component-type name {option}* )

component-type := :module | :file | :system | other-component-type

dependency := (dependent-op {requirement}+)
requirement := (required-op {required-component}+)
             | (test-feature feature-name)
dependent-op := operation-name
required-op := operation-name | test-feature

For example

(defsystem "foo"
  :components ((:module "foo" :components (:serial "bar" "baz" "quux")
	        :perform (compile-op :after (op c)
			  (do-something c))
		:explain (compile-op :after (op c)
			  (explain-something c)))
               (:file "blah")))


The method-form tokens need explaining: esentially, 

	        :perform (compile-op :after (op c)
			  (do-something c))
		:explain (compile-op :after (op c)
			  (explain-something c)))
has the effect of

(defmethod perform :after ((op compile-op) (c (eql ...)))
	   (do-something c))
(defmethod explain :after ((op compile-op) (c (eql ...)))
	   (explain-something c))

where ... is the component in question; note that while :before
methods are also supported by this, they may not do what you want them
to -  a :before method on perform ((op compile-op) (c (eql ...)))
will run after all the dependencies and sub-components have been
processed, but before the component in question has been
compiled.

*** Source location

The :pathname option is optional in all cases for native-syntax
systems, and in the usual case the user is recommended not to supply
it.  If it is not supplied for the top-level form, defsystem will set
it from

- The host/device/directory parts of *load-truename*, if it is bound
- *default-pathname-defaults*, otherwise

If a system is being redefined, the top-level pathname will be 

- changed, if explicitly supplied or obtained from *load-truename*
- changed if it had previously been set from *default-pathname-defaults*
- left as before, if it had previously been set from *load-truename*
  and *load-truename* is not now bound

These rules are designed so that (i) find-system will load a system
from disk and have its pathname default to the right place, (ii)
this pathname information will not be overwritten with
*default-pathname-defaults* (which could be somewhere else altogether)
if the user loads up the .asd file into his editor and
interactively re-evaluates that form

* Error handling

It is an error to define a system incorrectly: an implementation may
detect this and signal a SYSTEM-DEFINITION-ERROR or generalised
instance thereof

Operations may go wrong (for example when source files contain
errors).  These are signalled using generalised instances of
OPERATION-ERROR


----------------------------------------------------------
                      TODO List
----------------------------------------------------------

* Outstanding spec questions, things to add

** case-sensitivity wrt filenames

(1) components can be named using strings or symbols

(2) pathname computations for a component named by a symbol are
done using :case :common.  This applies in component-relative-pathname
and in find-system or whatever it calls to load the foo.asd file

** style guide for .asd files

You should either use keywords or be careful with the package that you
evaluate defsystem forms in.  Otherwise (defsystem partition ...)
being read in the cl-user package will intern a cl-user:partition
symbol, which will then collide with the partition:partition symbol.

Actually there's a hairier packages problem to think about too.
in-order-to is not a keyword: if you read defsystem forms in a package
that doesn't use ASDF, odd things might happen

** extending defsystem with new options

You might not want to write a whole parser, but just to add options to
the existing syntax.  Reinstate parse-option or something akin

** document all the error classes

* missing bits in implementation

** all of the above
** reuse the same scratch package whenever a system is reloaded from disk
** "and" and "or" dependencies are broken
** rules for system pathname defaulting are not yet implemented properly
** proclamations probably aren't
