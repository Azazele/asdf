asdf: another system definition facility                 -*- Text -*-

$Id: README,v 1.11 2002/02/14 11:37:58 dan_b Exp $

This system definition utility talks in terms of 'components' and
'operations'.

Components form systems: a component represents a source file, or a
collection of components.  A system is therefore a component,
recursively formed of a tree of subcomponents.

Operations are instantiated then performed on the nodes of a tree to
do things like

 - compile all its files
 - load the files into a running lisp environment
 - copy its source files somewhere else

Operations can be invoked directly, or examined to see what their
effects would be without performing them.  There are a bunch of 
methods specialised on operation and component type which actually do
the grunt work.

asdf is extensible to new operations and to new component types.  This
allows the addition of behaviours: for example, a new component could
be added for Java JAR archives, and methods specialised on
compile-op added for it that would accomplish the relevant
actions.

* Inspiration

** mk-defsystem (defsystem-3.x)

We aim to solve basically the same problems as mk-defsystem does.
However, our architecture for extensibility better exploits CL
language features (and is documented), and we intend to be portable
rather than just widely-ported.  No slight on the mk-defsystem authors
and maintainers is intended here; that implementation has the
unenviable task of supporting non-ANSI implementations, which I
propose to ignore.

The surface defsystem syntax of asdf is more-or-less compatible with
mk-defsystem

The mk-defsystem code for topologically sorting a module's dependency
list was very useful.

** defsystem-4 proposal

Marco and Peter's proposal for defsystem 4 served as the driver for
many of the features in here,  Notable differences are 

- we don't specify output files or output file extensions as part of
  the system

  If you want to find out what files an operation would create, ask
  the operation

- we don't deal with CL packages

  If you want to compile in a particular package, use an in-package
  form in that file (ilisp will like you more if you do this anyway)

- there is no proposal here that defsystem does version control.  

  A system has a given version which can be used to check
  dependencies, but that's all.

The defsystem 4 proposal tends to look more at the external features,
whereas this one centres on a protocol for system introspection.

** kmp's "The Description of Large Systems", MIT AI Memu 801

Available in updated-for-CL form on the web at 
http://world.std.com/~pitman/Papers/Large-Systems.html

In our implementation we borrow kmp's overall PROCESS-OPTIONS and
concept to deal with creating component trees from defsystem surface
syntax.

* component

** a component has:

*** A name (required)

This is a string.  It must be a suitable value for the :name initarg
to make-pathname in whatever filesystem the system is to be found.

*** a version identifier (optional, will default to parent's version)

This is used by the test-system-version operation (see later).

*** dependencies on its siblings  (optional but often necessary)

There is an excitingly complicated relationship between the initarg
and the method that you use to ask about dependencies

Dependencies are between (operation component) pairs.  In your
initargs, you can say

:in-order-to ((compile-op (load-op "a" "b") (compile-op "c"))
	      (load-op (load-op "foo")))

- before performing compile-op on this component, we must perform
load-op on each of "a" and "b", and before performing load-op, we have
to load "foo"

[ This is pretty similar to what ACL defsystem does.  mk-defsystem is
less general: it has an implied dependency 

  for all x, (load x) depends on (compile x)

and using a :depends-on argument to say that b depends on a _actually_
means that

  (compile b) depends on (load a) 

This is insufficient for e.g. the McCLIM system, which requires that
all the files are loaded before any of them can be compiled ]

In asdf, the dependency information for a given component and
operation can be queried using (depends-on operation component), which
returns a list

((load-op "a") (load-op "b") (compile-op "c") ...)

depends-on can be subclassed for more specific component/operation
types: these need to (call-next-method) and append the answer to their
dependency, unless they have a good reason for completely overriding
the default dependencies

(If it weren't for CLISP, we'd be using a LIST method combination to
do this transparently.  But, we need to support CLISP.  If you have
the time for some CLISP hacking, I'm sure they'd welcome your fixes)

*** a pathname

Optional, may be inferred from name, type (the subclass of
source-file), and location of parent.

The rules for this inference are:

(for source-files)
- the host is taken from the parent
- pathname type is (rassoc classname  *known-extensions* :test 'equal)
- the pathname case option is :local
- the pathname is merged against the parent

(for modules)
- the host is taken from the parent
- the name and type are NIL
- the directory is (:relative component-name)
- the pathname case option is :local
- the pathname is merged against the parent

Note that a component doesn't actually have any references to its
parent, so this inference will only be valid in the context of a
system operation (a special variable is bound to the location of
the parent while a child is processed)

Note that the DEFSYSTEM operator (used to create a "top-level" system)
does additional processing to set the filesystem location of the
top component in that system.  This is detailed elsewhere

** components are subclassed into 

*** 'source-file'

A source file is any file that the system does not know how to
generate from other components of the system. 

(Note that this is not necessarily the same thing as "a file
containing data that is typically fed to a compiler".  If a file is
generated by some pre-processor stage (e.g. a ".h" file from ".h.in"
by autoconf) then it is not, by this definition, a source file.
Conversely, we might have a graphic file that cannot be automatically
regenerated, or a proprietary shared library that we received as a
binary: these do count as source files for our purposes.  All
suggestions for better terminology gratefully received)

Subclasses of source-file exist for various languages.  

*** 'module', a collection of sub-components

This has extra slots :components and :default-component-class.  The
default operation knows how to traverse a module, so most operations
will not need to provide methods specialised on modules.

A system object is usually a module. 

The module may be subclassed to represent components such as
foreign-language linked libraries or archive files.

* operation

An operation is instantiated whenever the user asks that an operation
be performed, inspected, or etc.  The operation object contains
whatever state is relevant to this purpose (perhaps a list of visited
nodes, for example) but primarily is a nice thing to specialise
operation methods on and easier than having them all be EQL methods.

There are no differences between standard operations and user-defined
operations, except that the user is respectfully requested to keep his
(or more importantly, our) package namespace clean

** invoking operations

(oos operation system &rest keywords-args)

keyword-args are passed to the make-instance call when creating the
operation: valid keywords depend on the initargs that the operation is
defined to accept.

** standard operations

*** compile-op, load-op

When creating a new component, you should provide methods for these.  
As a user, you almost never want to use them, though.  See below.

*** compile-and-load-op &key proclamations

This is roughly equivalent to the mk-defsystem 'compile' operation.
Compiling a system usually involves loading each component after it is
compiled - we've changed the name of this operation to make it more
explicit what is happening

If proclamations are supplied, they will be proclaimed.  This is a
good place to specify optimization settings

You probably don't need to create this method if you are creating a new
component type.  The default method for this operation on source-files
calls compile-op and load-op

*** load-source-op

Sometimes systems have knotty dependencies which require that sources
are loaded before they can be compiled.  This is how you do that.

If you are creating a component type, you need to implement this
operation - at least, where meaningful.


*** test-system-version &key minimum

Asks the system whether it satisfies a version requirement.

The default method accepts a string, which is expected to contain of a
number of integers separated by #\. characters.  The method is not
recursive.  The component satisfies the version dependency if it has
the same major number as required and each of its sub-versions is
greater than or equal to the sub-version number required.

(defun version-satisfies (x y)
  (labels ((bigger (x y)
	     (cond ((not y) t)
		   ((not x) nil)
		   ((> (car x) (car y)) t)
		   ((= (car x) (car y))
		    (bigger (cdr x) (cdr y))))))
    (and (= (car x) (car y))
	 (or (not (cdr y)) (bigger (cdr x) (cdr y))))))

If that doesn't work for your system, you can override it.  I hope
yoyu have as much fun writing the new method as #lisp did
reimplementing this one. 

** Creating new operations

subclass operation, provide methods for source-file for 

- perform
- explain
- output-files
- operation-done-p, if you don't like the default one

* System definitions

** System designators

Strings and symbols are treated as system designators.  They are
transformed into actual system objects using

(find-system system-designator) => a MODULE object

In the case of a symbol, 
- the symbol name is taken
- if the system name is monocase and not in customary case for the
   filesystem, its case is inverted

No case translation is done for systems named by strings

This attempts to find the system in a file on the disk.  This file has
the name of the system, the type "system", and is looked for in each
of the directories given by evaluating members of *central-registry*.
The first matching file is considered, whether or not it turns out to
actually define the appropriate system

If a suitable file exists, it is loaded if

- there is no system of that name in memory, 
- the file's last-modified time exceeds the last-modified time of the
  system in memory

When system definitions are loaded from .system files, a new scratch
package is created for them to load into, so that different systems do
not overwrite each others operations.  The user may also wish to (and
is recommended to) include defpackage and in-package forms in his
system definition files, however, so that they can be loaded manually
if need be.

** Syntax

Systems can always be constructed programmatically by instantiating
components using make-instance.  For most purposes, however, it is
likely that people will want a static defystem form. 

asdf has `pluggable syntax', based around the principle that
components should not have to know defsystem syntax.  That is, the
initargs that a component accepts are not necessarily related to the
defsystem form which creates it.  defsystem forms are parsed by
methods of generic functions which can be specialised for new
syntaxes.

A defsystem parser must implement a `defsystem' macro, which can
be named for compatibility with whatever other system definition
utility is being emualted.  It probably would look something like this:

(defmacro mk:defsystem (name &rest options)
  (parse-component-form mk-syntax ,name ,options))

Internally the parser implements a method for parse-component-form,
which is called in the following fashion:

(parse-component-form syntax parent '(:module name :op1 val1 :op2 (blah blah)))

It should return a component.  It gets the parent component available
to it, and should test whether the component to be created already
exists (as it might in a system redefinition) and update it in place
if so

[ Why are we specifying this?  The complete parsing is under the
control of the person who implements a defsystem macro: given that we
don't even do the recursion for him, is there any point in our
specifying a protocol that he should use?  Useful stuff we could 
write, though, is the interface that the defsystem form thus created
should use to register the new system where find-system can get at it ]


** Native syntax

The native syntax is inspired by mk-defsystem, to the extent that it
should be possible to take most straightforward mk- system definitions
and run them unchanged.  For my convenience, this turns out to be
basically the same as the initargs to the various components, with
a few extensions for convenience
               
system-definition := ( defsystem system-designator {option}* )

option := :components component-list
        | :pathname pathname
        | :default-component-class
        | :perform method-form 
        | :explain method-form
	| :output-files  method-form
        | :operation-done-p method-form
        | :depends-on ( {simple-component-name}* ) 
	| :serialize [ t | nil ]
        | :in-order-to 

component-list := ( {component-def}* )
                
component-def  := simple-component-name
                | ( component-type name {option}* )

component-type := :module | :file | :system | other-component-type


For example

(defsystem "foo"
  :components ((:module "foo" :components (:serial "bar" "baz" "quux")
	        :perform (compile-op :after (op c)
			  (do-something c))
		:explain (compile-op :after (op c)
			  (explain-something c)))
               (:file "blah")))


The method-form tokens need explaining: esentially, 

	        :perform (compile-op :after (op c)
			  (do-something c))
		:explain (compile-op :after (op c)
			  (explain-something c)))
has the effect of

(defmethod perform :after ((op compile-op) (c (eql ...)))
	   (do-something c))
(defmethod explain :after ((op compile-op) (c (eql ...)))
	   (explain-something c))

where ... is the component in question; note that while :before
methods are also supported by this, they may not do what you want them
to -  a :before method on perform ((op compile-op) (c (eql ...)))
will run after all the dependencies and sub-components have been
processed, but before the component in question has been
compiled.

*** Source location

The :pathname option is optional in all cases for native-syntax
systems.  If it is not supplied for the top-level form, defsystem will
set it from

- *load-truename*, if it is bound
- *default-pathname-defaults*, otherwise

If a system is being redefined, the top-level pathname will be 

- changed, if explicitly supplied or obtained from *load-truename*
- changed if it had previously been set from *default-pathname-defaults*
- left as before, if it had previously been set from *load-truename*
  and *load-truename* is not now bound
  

* Error handling

It is an error to define a system incorrectly: an implementation may
detect this and signal a SYSTEM-DEFINITION-ERROR or generalised
instance thereof

Operations may go wrong (for example when source files contain
errors).  These are signalled using generalised instances of
OPERATION-ERROR


----------------------------------------------------------
                      TODO List
----------------------------------------------------------

* Outstanding spec questions, things to add

** initially-do

The mk-alike :initially-do and :finally-do are ugly, but are they
doing anything that's (a) useful, and (b) not convenient with
:perform :after?

** case-sensitivity wrt filenames

Presently we do no case munging except for symbols in find-system.  To
find a .system file we (make-pathname :name name :type "SYSTEM" :case
:common) ("use the file system's customary case") which translates
this uppercase into whatever case is nicest (lowercase for sbcl on
unix)

We have excitingly chunky rules for merging component names, which
need to be documented.  Oh, and implemented.

** symbols vs strings

Warn the user that they should either use keywords or be careful with
the package that they evaluate defsystem forms in.  Otherwise
(defsystem partition ...) being read in the cl-user package will
intern a cl-user:partition symbol, which will then collide with the
partition:partition symbol

** error reporting

Need an explicit error for "dependency missing" and "required version
of dependency missing" so that we can fit this to an automated
dependency downloading thing.  

* missing bits in implementation
** all of the above
** reuse the same scratch package whenever a system is reloaded from disk
** defsystem syntax for EQL methods

How the hell  Cop out and use EVAL?

** versions
** test suite, insofar as it makes sense
** compiler/loader options
 verbosity, proclamations, etc: do this with specials

(defvar *visited-nodes* nil)
(defvar *visiting-nodes* nil)

rewrite the component-visiting stuff to hide this state in the
operation 


** pathname defaulting in defsystem
