asdf: another system definition facility                 -*- Text -*-

$Id: README,v 1.2 2001/08/02 19:09:07 dan_b Exp $

This system definition utility talks in terms of 'components' and
'operations'.

Components form systems: a component represents a source file, or a
collection of components.  A system is therefore a component,
recursively formed of a tree of subcomponents.

Operations are instantiated then performed on the nodes of a tree to
do things like

 - compile all its files
 - load the files into a running lisp environment
 - copy its source files somewhere else

Operations can be invoked directly, or examined to see what their
effects would be without performing them.  There are a bunch of 
methods specialised on operation and component type which actually do
the grunt work.

asdf is extensible to new operations and to new component types.  This
allows the addition of behaviours: for example, a new component could
be added for Java JAR archives, and methods specialised on
compile-system added for it that would accomplish the relevant
actions.

asdf is not presently extensible to new syntax (for example, to
emulate other defsystem utilities), but that's on the cards for a
future version.

* Inspiration

** mk-defsystem (defsystem-3.x)

We aim to solve basically the same problems as mk-defsystem does.
However, our architecture for extensibility better exploits CL
language features (and is documented), and we intend to be portable
rather than just widely-ported.  No slight on the mk-defsystem authors
and maintainers is intended here; that implementation has the
unenviable task of supporting non-ANSI implementations, which I
propose to ignore.

The surface defsystem syntax of asdf is more-or-less compatible with
mk-defsystem

The mk-defsystem code for topologically sorting a module's dependency
list was very useful.

** defsystem-4 proposal

Marco and Peter's proposal for defsystem 4 served as the driver for
many of the features in here,  Notable differences are 

- we don't specify output files or output file extensions as part of
  the system

  If you want to find out what files an operation would create, ask
  the operation

- we don't deal with CL packages

  If you want to compile in a particular package, use an in-package
  form in that file (ilisp will like you more if you do this anyway)

- there is no proposal here that defsystem does version control.  

  A system has a given version which can be used to check
  dependencies, but that's all.

The defsystem 4 proposal tends to look more at the external features,
whereas this one centres on a protocol for system introspection.

** kmp's "The Description of Large Systems", MIT AI Memu 801

Available in updated-for-CL form on the web at 
http://world.std.com/~pitman/Papers/Large-Systems.html

In our implementation we borrow kmp's overall PROCESS-OPTIONS and
PROCESS-OPTION concepts to deal with creating component trees from
defsystem surface syntax.  We haven't yet decided whether or how to
present this to users (i.e to specify it) but that will probably
happen one way or another.

* component

** a component has:

*** A name (required)

This is a string.  It must satisfy the restrictions imposed on a
portable pathname character.

*** a version identifier (optional, will default to parent's version)

This is used by the check-component-version operation (see later).

*** dependencies on its siblings  (optional but often necessary)

This slot contains a list whose elements are each names of siblings,
or lists of (name version) for siblings

[ this will change.  Dependencies are between (component operation)
pairs, not between components themselves ]

*** a filesystem location

Optional, may be inferred from name, type (the subclass of
source-file), and location of parent.

Note that a component doesn't actually have any references to its
parent, so this inference will only be valid in the context of a
system operation (a special variable is bound to the location of
the parent while a child is processed)

** components are subclassed into 

*** 'source-file'

A source file is any file that the system does not know how to
generate from other components of the system. 

(Note that this is not quite the same thing as "a file containing data
that is typically fed to a compiler".  If a file is generated by some
pre-processor stage (e.g. a ".h" file from ".h.in" by autoconf) then
it is not, by this definition, a source file.  Conversely, we might
have a graphic file that cannot be automatically regenerated, or a
proprietary shared library that we received as a binary: these do
count as source files for our purposes.  All suggestions for  better
terminology gratefully received)

Subclasses of source-file exist for various languages.  

*** 'module', a collection of sub-components

This has extra slots :components and :default-component-class.
Most operations will not need to provide methods specialised on
modules, as the tree traversal happens automatically,

A system object is usually a module. 

The module may be subclassed to represent components such as
foreign-language linked libraries or archive files.

* operation

An operation is instantiated whenever the user asks that an operation
be performed, inspected, or etc.  The operation object contains
whatever state is relevant to this purpose (perhaps a list of visited
nodes, for example) but primarily is a nicer thing to specialise
operation methods on than having them all be EQL methods.

There are no differences between standard operations and user-defined
operations, except that the user is respectfully requested to keep his
(or more importantly, our) package namespace clean

** invoking operations

(oos operation system &rest keywords-args)

keyword-args are passed to the make-instance call when creating the
operation: valid keywords depend on the initargs that the operation is
defined to accept.

** standard operations

*** compile-system &key proclamations

The definition of `compile' is "do everything that we can do to make
subsequent loads (in a new image that we didn't do the compile in)"
faster.

If proclamations are supplied, they will be proclaimed.  This is a
good place to specify optimization settings

*** load-system

This is the `do everything' operation.  It depends on compile-system.

*** test-system-version &key minimum

Asks the system whether it satisfies a version requirement.

The default method accepts a string, which is expected to contain of a
number of integers separated by #\. characters.  The method is not
recursive.  The component satisfies the version dependency if it has
the same major number as required and each of its sub-versions is
greater than or equal to the sub-version number required.

(defun version-satisfies (x y)
  (labels ((bigger (x y)
	     (cond ((not y) t)
		   ((not x) nil)
		   ((> (car x) (car y)) t)
		   ((= (car x) (car y))
		    (bigger (cdr x) (cdr y))))))
    (and (= (car x) (car y))
	 (or (not (cdr y)) (bigger (cdr x) (cdr y))))))

If that doesn't work for your system, you can override it.  I hope
yoyu have as much fun writing the new method as #lisp did
reimplementing this one. 

** Creating new operations

subclass operation, provide methods for source-file for 

- perform
- explain
- output-files
- operation-done-p, if you don't like the default one

* System definitions

** Finding them

(find-system name) => a MODULE object

Systems are named by strings.  If a system is not present in memory
when asked for, attempts are made to load a file which is expected to
define it.  This file has the name of the system, the type "system",
and is looked for in each of the directories given by evaluating 
members of *central-registry*

A system may also be referred to by symbol.  In this case the symbol
name is taken before a lookup is performed.

When system definitions are loaded from .system files, a new scratch
package is created for them to load into, so that different systems
do not overwrite each others operations.  The user may also wish 
to include defpackage and in-package forms in his system definiton
files, however, so that they can be loaded manually if need be.

** Syntax

There is a defsystem form which looks basically similar to
mk-defsystem syntax

We extend the defsystem syntax to allow for eql-specialised methods on
components -

  (:module "foo" (:components "bar" "baz" "quux")
	         (:perform compile-system :after (op c)
			   (do-something c))
		 (:explain compile-system :after (op c)
			   (explain-something c))

has the effect of

(defmethod perform :after ((op compile-system) (c (eql ...)))
	   (do-something c))
(defmethod explain :after ((op compile-system) (c (eql ...)))
	   (explain-something c))

where ... is the component in question

** shorthand for source-file components

source-file components defined with (:file "a-string") or "a-string"
will have the string parsed into name and type as if it were a
filename, and an instance of the appropriate source-file subclass
created.  If a type is not provided, it will default to the parent's
default component type.

* Error handling

It is an error to define a system incorrectly: an implementation may
detect this and signal a SYSTEM-DEFINITION-ERROR or generalised
instance thereof

Operations may go wrong (for example when source files contain
errors).  These are signalled using generalised instances of
OPERATION-ERROR

----------------------------------------------------------
                      TODO List
----------------------------------------------------------

* Outstanding spec questions, things to add

** Finding code: ":source-pathname " is not really good enough unless
 LPNs suddenly develop union filesystem semantics

** case-sensitivity wrt filenames

Convention is to refer to systems with symbols, which means they end
up being named by uppercase strings.  To find a .system file we
(make-pathname :name name :type "SYSTEM" :case :common) ("use the file
system's customary case") which translates this uppercase into
whatever case is nicest (lowercase for sbcl on unix)

For merging component names we use whatever the user supplied -
probably lowercase - and lowercase extensions, with :case :local.
This appears to work out fine, but but I haven't thought too hard
about it

** symbols vs strings

Warn the user that they should either use keywords or be careful with
the package that they evaluate defsystem forms in

<Krystof> You don't want to have (defsystem partition ...) being read in the
+cl-user package
<rahul> hrm
<Krystof> Because that will intern a cl-user:partition symbol
<rahul> yeah, accidental interning could be a problem
<Krystof> Which will then collide with the partition:partition symbol
<Krystof> Hence (defsystem :partition ...)
<rahul> yeah


** defsystem syntax
*** export process-option-list?
*** shortcut to setting up dependencies using :serial, :parallel
  options.
*** split into native syntax and mixin for mk- syntax extras

** Argh dependencies.

Our dependencies are conceptually wrong.  Dependencies exist between
the application of operations to components, not the components
themselves.  For example, there is an implied dependency in
mk-defsystem

  for all x, (load x) depends on (compile x)

and specifying that b depends on a _actually_ means that

  (compile b) depends on (load a)

We should do this the more general way internally even if it never
gets to surface syntax; it'd make the whole "compile-after-load"
stuff a lot cleaner.  

** the :pathname argument is misnamed

As demonstrated by the way we split it into name and type ourselves
instead of using parse-namestring, to avoid the problem that "foo.lisp"
is an absolute director when treated as an LPN.  As it doesn't behave
like a pathname, we shouldn't fool the user into thinking it is one

<dan_b> because "foo.lisp" in an LPN is an absolute path
<Krystof> So you should be merging the other way round, no?
<Krystof> (merge-pathname *component-pathname-defaults* "foo.lisp")
[ no ]

<Krystof> But you can't currently do ((:file "/absolute/file/that/I/want.lisp")) anyway
[ this is true ]

* missing bits in implementation
** all of the above
** package exports

present list is ad-hoc, so go through and consider it properly

** reuse the same scratch package whenever a system is reloaded from disk
** defsystem syntax for EQL methods
** dependency circularities: test it works
** versions


