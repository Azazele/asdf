* Syntax control: objective

What is the problem that we are trying to fix?

We are trying to fix uncontrolled, unintentional leaking of
readtable side effects to systems that depend on such effects not happening,
without removing /intended/ leaking of readtable side effects
to systems that do depend on such effects happening.

* Syntax Control: implement and document this plan

1. ASDF (actually UIOP) maintains a =uiop:*shared-readtable*=, which is bound
   to the value of =cl:*readtable*= at the time ASDF was loaded,
   which is the /initial readtable/.
   The variable =*shared-readtable*= is not intended to be rebound
   after having been initialized; its value is an object of type =readtable=,
   hereafter known as the /shared readtable/.
   
   Points that need to be settled:
   + Should =*shared-readtable*= be bound as the value of =cl:*readtable*= at
     the time ASDF was loaded, or as the return value of =(copy-readtable nil)=?
     On the one hand, the latter is portable and clean.  However, Fare reports
     "my understanding is that several implementations provide extensions in the
     /initial readtable/ that are *not* part of the /standard readtable/, such
     as a #! ignorer sometimes, or importantly in CCL the =#$= and =#_= readers,
     etc.  I understand that a strict reading of the CLHS might make this
     non-conformant, but I suspect that many systems rely on it, as I believe
     the ITA codebase for QRes did."
     
     This seems to me (rpg) to be an interesting, unresolved ASDF issue: should
     an ASDF user be able to specify that his/her system is intended either to
     be portable, or to be tied to a specific CL implementation (or set of
     implementations)?  It seems like the above question could have more than
     one answer: if you want portable code, you want =(copy-readtable nil)=; if
     you want to exploit your implementation's extensions, you want the value of
     =cl:*readtable*= at ASDF load time.
     
     Follow-up question: if the implementation bundles ASDF, is "the time ASDF
     was loaded" well-defined?

   + Should the variable should be named =*initial-readtable*=, instead?  I
     (rpg) don't believe so.  Its value is the initial readtable, but it will
     then be modified, so I think "shared" better covers the intended purpose.

2. Modification of the readtable object to which =*shared-readtable*= is bound
   is subject to the the following restrictions (also discussed in
   the ASDF manual, in the section "How do I work with readtables?"):

   *NOTE:* be sure to update the manual to match this document after it's
   settled.

  A. no modifying any standard character,
  B. No two systems loaded in the same image may assign different meanings
   to a same character in the =*shared-readtable*=.
   [RPG: Follow-up question: is this condition checkable?  I am not up to speed
   on portable facilities for access to =readtable='s.  If ASDF doesn't check
   this, I think it will be hard for the programmer to check it.]
   [FRR: I don't think this is checkable without implementation support,
   unless maybe you're ready to pay the price of walking 1 million records
   and compare your two readtables character by character, and potentially
   square that because of =dispatch-macro-character= ].
  C. libraries need to document any change to =*shared-readtable*=. Note that
   unqualified readtable modifications in the program will modify the object
   to which =*readtable*= is bound, which unless rebound will also be object
   to which =*shared-readtable*= is bound.
  D. free software libraries will register these changes on the page on cliki.net

   It is an error to modify the =*shared-readtable*= in ways that violate these
   restrictions.
   
   [RPG: Question is the above error claim too restrictive?  Let's say I am
   developing system C.  C depends on both A and B.  I /know/ that A and B both
   modify the =*shared-readtable*= entry for character x.  I can't /fix/ this,
   since I don't own either A or B.  But I can enforce an ordering that loads B
   after A, giving me the value for character x that I want.  If I do this, why
   should ASDF claim that system C is erroneous?]

3. Unhappily, there is no cheap way to enforce these restrictions, but that's no
   regression with respect to the current situation.

4. ASDF binds =*readtable*= to =*shared-readtable*= around any
   =perform compile-op= and =perform load-source-op=

5. Systems that want to modify a persistent, shared readtable in ways that
   violate (2) must arrange to use their own private readtable, but can
   otherwise do it safely.

   Systems that wish to make a modified readtable available should export an API
   function to set the value of =*readtable*= appropriately.

6. Implementation:

   A. ASDF binds =*readtable*= to the =*shared-readtable*= at the start of every
   system's compilation (and loading?), and around the entire =asdf:operate=,
   leaving the =*readtable*= unchanged at the end.
   [RPG: Please clarify -- I don't see how we can wrap around the entire
   =operate= while at the same time /not/ doing loading as well as compilation.
   What's the precise scope of the binding of =*readtable*=?]
   [FRR: we wrap around both the entire =operate= and individual actions,
   so that even if some action manages to modify the value of =*readtable*=,
   still that won't pollute the next compilation action, yet things that happen
   in-between are also protected, although at a more global level.]

   [FRR: we don't bind around individual =load-op= operations, so that
   when loading a fasl as opposed to a lisp source file, load-time
   side-effects to the =*readtable*= variable won't be cancelled around each
   file by binding =*readtable*= to =*shared-readtable*=, though a strict reading
   of the CLHS says this implicitly happens when loading, irrespective of
   the loading being =.fasl= or =.lisp=. In case it isn't, though, we don't try,
   because that doesn't happen when we concatenate fasls, and we want to
   be as compatible with that as possible.]

   This easily supports systems that "modify the current readtable data
   structure".

* ANSI spec description of binding of readtable
+ [[http://www.lispworks.com/documentation/HyperSpec/Issues/iss196_w.htm][ANSI spec issue "IN-SYNTAX"]]
+ [[http://www.lispworks.com/documentation/HyperSpec/Body/f_cmp_fi.htm]["compile-file binds =*readtable*= and =*package*= to the values they held before processing the file."]]
+ [[http://www.lispworks.com/documentation/HyperSpec/Body/f_load.htm]["load binds =*readtable*= and =*package*= to the values they held before /loading/ the file."]]


* Alternative Plan

The following describes an alternative approach, more ambitious and complicated,
which was /not/ implemented.  It is provided here for comparison purposes and
because of the light it sheds on design rationale.

The preceding, simpler approach does not handle systems that "bind =*readtable*=
to a new value", because the changes they make will shadow the changes that
other systems following this style make and depend on.
No ASDF system can currently do this in a regular =LOAD-OP= or =COMPILE-OP=,
because the CLHS mandates binding =*readtable*= around LOAD and COMPILE-FILE
(see [[http://www.lispworks.com/documentation/HyperSpec/Issues/iss196_w.htm][ANSI spec issue "IN-SYNTAX"]]).  However, ASDF systems can conceivably do it
in a =perform= method, and can indeed do it in an initialization function that
the user calls with or without understanding the =*readtable*= change that
occurs and its implications.

To allow such an idiom, ASDF could perform a much more ambitious computation,
tracking the readtable through ASDF operations.  In the event, this is overkill
since =load= and =compile-file= do the readtable protection 
(see [[*ANSI spec description of binding of readtable]]) although if 
we wanted to extend that to other variables not protected by the ANSI spec,
notably the =*print-pprint-dispatch*=, that would make more sense.

1. ASDF binds =*readtable*= to a proper "entry readtable" at the start of every
   system's compilation, and records an "exit readtable" at the end of the
   system's loading.

2. Maintain a partial order on these readtable objects, assuming that each
   system's exit readtable supersedes the entry readtable. The least readtable
   is the =*shared-readtable*=. It's enough to store for each new exit
   readtable, identified by the name of system that created it, the set of its
   inferior readtables, as a list or eq-hash-table, or an equal hash-table, with
   each readtable being identified by the name of the system that created it.

3. Before a system is compiled or loaded, compute the a dependency graph of
   readtables.  We effectively compute the maximum readtable of all the exit
   readtables of the system's dependencies. If this maximum is unique, then it
   will be the entry readtable of the system. If there is not a unique readtable
   that is more than all the other ones, that's an error, and we refuse to load
   the system.

4. After a system is loaded, check its exit readtable, if it already exists,
   check that this doesn't create a cycle or issue an error. If the exit
   readtable doesn't already exist, add it to the set of all known exit
   readtables.

5. ASDF either

   1. binds the =*readtable*= to the =*shared-readtable*= around the entire
      =asdf:operate=, leaving the =*readtable*= unchanged at the end, or

   2. always side-effects the =*readtable*= to correspond to the exit readtable of
      the loaded system, or

   3. =operate= does the binding around thing, but =load-system= does the side-effect
      after it's done operate'ing.

Does that strike you as complex? Because it is. That's the price of
*safely* supporting this "systems can bind a new value to =*readtable*="
style.

# Local Variables:
# mode: org
# End:
