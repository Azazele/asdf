* Syntax control: objective

What is the problem that we are trying to fix?

We are trying to fix uncontrolled, unintentional leaking of
readtable side effects to systems that depend on such effects not happening,
without removing /intended/ leaking of readtable side effects
to systems that do depend on such effects happening.

* Syntax Control: implement and document this plan

1. ASDF (actually UIOP) maintains a =uiop:*shared-readtable*=, which is bound
   to the value of =cl:*readtable*= at the time ASDF was loaded,
   which is the /initial readtable/.
   The variable =*shared-readtable*= is not intended to be rebound
   after having been initialized; its value is an object of type =readtable=,
   hereafter known as the /shared readtable/.

   [RPG: What is the intended function of the *shared-readtable* as distinct from
    the default readtable?]
   [FRR: this *is* the default readtable. There is no other way to get to the
   /initial readtable/ as opposed to (a copy of) the /standard readtable/,
   which could be different and contain extensions, though since it *initially*
   shouldn't contain extensions, I suppose we could use =(copy-readtable nil)=]
   [RPG: I think if it's sanitation we are hoping for, then
   =(copy-readtable nil)= is The Right Thing.  It eliminates the potential for
   getting unpredictable results by delaying load of ASDF.]
   [FRR: I would have liked to agree, but my understanding is that several
   implementations provide extensions in the /initial readtable/ that are *not*
   part of the /standard readtable/, such as a #! ignorer sometimes, or
   importantly in CCL the =#$= and =#_= readers, etc.
   I understand that a strict
   reading of the CLHS might make this non-conformant, but I suspect that
   many systems rely on it, as I believe the ITA codebase for QRes did.]
   [FRR: maybe the variable should be named =*initial-readtable*= then?]

   [RPG: Proposed answer to my own question: the =*shared-readtable*= is
   provided as a convenience for libraries that ...]
   [FRR: missing text above]

2. Modification of the readtable object to which =*shared-readtable*= is bound
   is subject to the the following restrictions (also discussed in
   the ASDF manual, in the section "How do I work with readtables?"):

   [FRR: be sure to update the manual to match this document after it's settled.]

  A. no modifying any standard character,
  B. No two systems loaded in the same image may assign different meanings
   to a same character in the =*shared-readtable*=.
   [RPG: Spliced in FRR's admirably clear phrasing.  Pulled out the hedge "as
   bound to," which I beleive to be unnecessary.]
   [RPG: Follow-up question: is this condition checkable?  I am not up to speed
   on portable facilities for access to =readtable='s.  If ASDF doesn't check
   this, I think it will be hard for the programmer to check it.]
   [FRR: I don't think this is checkable without implementation support,
   unless maybe you're ready to pay the price of walking 1 million records
   and compare your two readtables character by character, and potentially
   square that because of =dispatch-macro-character=]
  C. libraries need to document any change to =*shared-readtable*=. Note that
   unqualified readtable modifications in the program will modify the object
   to which =*readtable*= is bound, which unless rebound will also be object
   to which =*shared-readtable*= is bound.
  D. free software libraries will register these changes on the page on cliki.net

   It is an error (unhappily not enforceable) to modify the =*shared-readtable*=
   in ways that violate these restrictions.

3. Unhappily, there is no cheap way to enforce these restrictions, but that's no
   regression with respect to the current situation.

   [RPG: See above: can't we check 2B, at least?]

4. ASDF binds =*readtable*= to =*shared-readtable*= around any
   =perform compile-op= and =perform load-source-op=

5. Systems that want to modify a persistent, shared readtable in ways that
   violate (2) must arrange to use their own private readtable, but can
   otherwise do it safely.

   Systems that wish to make a modified readtable available should export an API
   function to set the value of =*readtable*= appropriately.

6. Implementation:

   A. ASDF binds =*readtable*= to the =*shared-readtable*= at the start of every
   system's compilation (and loading?), and around the entire =asdf:operate=,
   leaving the =*readtable*= unchanged at the end.
   [RPG: Please clarify -- I don't see how we can wrap around the entire
   =operate= while at the same time /not/ doing loading as well as compilation.
   What's the precise scope of the binding of =*readtable*=?]
   [FRR: we wrap around both the entire =operate= and individual actions,
   so that even if some action manages to modify the value of =*readtable*=,
   still that won't pollute the next compilation action, yet things that happen
   in-between are also protected, although at a more global level.]

   [FRR: we don't bind around individual =load-op= operations, so that
   when loading a fasl as opposed to a lisp source file, load-time
   side-effects to the =*readtable*= variable won't be cancelled around each
   file by binding =*readtable*= to =*shared-readtable*=, though a strict reading
   of the CLHS says this implicitly happens when loading, irrespective of
   the loading being =.fasl= or =.lisp=. In case it isn't, though, we don't try,
   because that doesn't happen when we concatenate fasls, and we want to
   be as compatible with that as possible.]

   This easily supports systems that "modify the current readtable data
   structure".

   However, that doesn't handle systems that "bind =*readtable*= to a new value",
   because the changes they make will shadow the changes that other systems
   following this style make and depend on.

   [RPG: We need to clarify the preceding sentence. In particular, given the way
    CL works today, we can't actually /bind/ =*readtable*= in a useful way:
    we always end up setting it. A simple example would help.]
   [FRR: no system can currently do it in a regular LOAD-OP or COMPILE-OP,
    because the CLHS mandates the bind around LOAD and COMPILE-FILE;
    but they can conceivably do it in a perform method, and can indeed
    do it in an initialization function that the user calls with or without
    understanding the =*readtable*= change that occurs and its implications.]

   To allow such an idiom, we must also do the following:

   B. ASDF binds =*readtable*= to a proper "entry readtable" at the start of
   every system's compilation, and records an "exit readtable" at the end of the
   system's loading. [RPG: 6B seems to directly contradict 4.]

   [FRR: yes, 5B and the following constitute a more elaborate *alternate plan* that
   wasn't implemented, and that I wrote before I realized the CLHS mandated that
   =*readtable*= be bound by =load= and =compile-file=, which make this plan quite
   overkill unless someone modifies the =*readtable*= variable in a magic =perform=
   method on =prepare-op= (and =prepare-source-op=) without restoring it at the end
   of =compile-op= (and =load-source-op=) and we want to support that.
   I suppose we should just do away with that alternate plan.]

   1. Maintain a partial order on these readtable objects, assuming that each
      system's exit readtable supersedes the entry readtable. The least readtable
      is the =*shared-readtable*=. It's enough to store for each new exit readtable,
      identified by the name of system that created it, the set of its inferior
      readtables, as a list or eq-hash-table, or an equal hash-table, with each
      readtable being identified by the name of the system that created it.

   2. Before a system is compiled or loaded, compute the maximum readtable of
      all the exit readtables of its dependencies. If this maximum is unique,
      then it will be the entry readtable of the system. If there is not a
      unique readtable that is more than all the other ones, that's an error,
      and we refuse to load the system.

     [RPG: I /think/ I follow this: the idea is to compute what the actual
      readtable dependencies are, as a means of ensuring repeatability, as build
      operations may be interleaved in different situations.]

     [RPG: Another point -- we aren't actually computing the maximum readtable
      as a readtable object, are we?  Instead we are computing a dependency
      graph, right?  And the nodes are readtable /designators/, rather than
      readtables, right?]

     [FRR: yes, in that alternate plan, we don't (can't) merge objects, but
      assume that the programs somehow do use copy-readtable followed by
      modification of what then constitutes a tree of readtable objects,
      and we ensure that =*readtable*= is bound to the correct readtable object
      when loading a system. Once again, this is overkill since =load= and
      =compile-file= do the readtable protection, although if we wanted to
      extend that to other variables not protected by the CLHS, notably the
      =*print-pprint-dispatch*=, then that would make more sense.]

   3. After a system is loaded, check its exit readtable, if it already exists,
   check that this doesn't create a cycle or issue an error. If the exit
   readtable doesn't already exist, add it to the set of all known exit
   readtables.

7. ASDF either

   1. binds the =*readtable*= to the =*shared-readtable*= around the entire
      =asdf:operate=, leaving the =*readtable*= unchanged at the end, or

   2. always side-effects the =*readtable*= to correspond to the exit readtable of
      the loaded system, or

   3. =operate= does the binding around thing, but =load-system= does the side-effect
      after it's done operate'ing.

Does that strike you as complex? Because it is. That's the price of
*safely* supporting this "systems can bind a new value to =*readtable*="
style. Unhappily some of the constraints are not enforceable (2A and
2B), but that's the very same as now.

So my next question is: do you want to safely support these
conventions? Do your systems modify the current =*readtable*= structure,
or do they bind =*readtable*= to a new value?

[RPG: So what is implemented in the syntax-control branch?]
[FRR: The first simpler plan, 1-5, 6A is implemented.
The more complex plan 1-5, 6B isn't.]
[RPG: Got it.  And do we do 7.1, 7.2, or 7.3?]
[FRR: None, since 7 is part of plan B, which we don't implement,
amd which seems overkill now that it's established that
the CLHS mandates that =load= and =compile-file= bind =*readtable*=]

# Local Variables:
# mode: org
# End:
